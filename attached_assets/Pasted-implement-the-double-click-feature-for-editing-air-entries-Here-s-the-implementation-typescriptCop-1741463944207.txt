implement the double-click feature for editing air entries. Here's the implementation:
typescriptCopy// Add to the Canvas2D props interface
interface Canvas2DProps {
  gridSize: number;
  currentTool: 'wall' | 'eraser' | null;
  currentAirEntry: 'vent' | 'door' | 'window' | null;
  airEntries: AirEntry[];
  lines: Line[];
  onLinesUpdate?: (lines: Line[]) => void;
  onAirEntriesUpdate?: (airEntries: AirEntry[]) => void;
  onAirEntryEdit?: (entry: AirEntry, index: number) => void; // New prop for handling edit requests
}

// Add a helper function to detect double clicks on air entries
const findAirEntryAtLocation = (clickPoint: Point): { index: number; entry: AirEntry } | null => {
  console.log("Checking for AirEntry at point:", clickPoint);

  for (let i = 0; i < airEntries.length; i++) {
    const entry = airEntries[i];
    const normal = calculateNormal(entry.line);
    const widthInPixels = cmToPixels(entry.dimensions.width);
    const halfWidth = widthInPixels / 2;

    const start = {
      x: entry.position.x - normal.x * halfWidth,
      y: entry.position.y - normal.y * halfWidth
    };

    const end = {
      x: entry.position.x + normal.x * halfWidth,
      y: entry.position.y + normal.y * halfWidth
    };

    const distanceToEntry = distanceToLineSegment(clickPoint, start, end);
    console.log("Distance to entry:", distanceToEntry, "Entry index:", i);

    if (distanceToEntry < 20 / zoom) {
      console.log("Found AirEntry at index:", i);
      return { index: i, entry };
    }
  }

  console.log("No AirEntry found at point");
  return null;
};

// Add state for tracking double-clicks
const [lastClickTime, setLastClickTime] = useState<number>(0);
const [lastClickPosition, setLastClickPosition] = useState<Point | null>(null);

// Add double-click handling to the mouseDown function
const handleMouseDown = (e: MouseEvent) => {
  // Handle right-click first (remains the same)
  if (e.button === 2) {
    e.preventDefault();
    // ... existing right-click handling ...
    return;
  }

  const clickPoint = getCanvasPoint(e);
  
  // Check for double-click
  const currentTime = Date.now();
  const isDoubleClick = currentTime - lastClickTime < 300 && 
                        lastClickPosition && 
                        Math.abs(clickPoint.x - lastClickPosition.x) < 10 && 
                        Math.abs(clickPoint.y - lastClickPosition.y) < 10;
  
  setLastClickTime(currentTime);
  setLastClickPosition(clickPoint);
  
  // If it's a double-click, check if we clicked on an air entry
  if (isDoubleClick) {
    const airEntryInfo = findAirEntryAtLocation(clickPoint);
    if (airEntryInfo && onAirEntryEdit) {
      onAirEntryEdit(airEntryInfo.entry, airEntryInfo.index);
      return;
    }
  }
  
  // Continue with existing single-click logic
  if (currentTool === 'wall') {
    // ... existing wall tool logic ...
  } else if (currentTool === 'eraser') {
    // ... existing eraser tool logic ...
  } else if (currentAirEntry) {
    // ... existing air entry creation logic ...
  }
};
Now in the parent component that uses Canvas2D, you'll need to implement the handler for editing:
tsxCopy// In the parent component
const [isEditModalOpen, setIsEditModalOpen] = useState(false);
const [editingAirEntry, setEditingAirEntry] = useState<{ entry: AirEntry | null, index: number | null }>({
  entry: null,
  index: null
});

// Handler for edit requests from Canvas2D
const handleAirEntryEdit = (entry: AirEntry, index: number) => {
  setEditingAirEntry({
    entry,
    index
  });
  setIsEditModalOpen(true);
};

// Handler for when the modal is submitted with edited values
const handleEditModalSubmit = (editedEntry: AirEntry) => {
  if (editingAirEntry.index !== null) {
    const updatedAirEntries = [...airEntries];
    updatedAirEntries[editingAirEntry.index] = {
      ...editedEntry,
      // Make sure to preserve the line and lineId
      line: editingAirEntry.entry!.line,
      lineId: editingAirEntry.entry!.lineId
    };
    setAirEntries(updatedAirEntries);
  }
  setIsEditModalOpen(false);
  setEditingAirEntry({ entry: null, index: null });
};

// In your render function
return (
  <>
    <Canvas2D
      // ... other props ...
      airEntries={airEntries}
      onAirEntriesUpdate={setAirEntries}
      onAirEntryEdit={handleAirEntryEdit}
    />
    
    {/* The modal dialog */}
    <AirEntryModal 
      isOpen={isEditModalOpen || isCreationModalOpen} 
      onClose={() => {
        setIsEditModalOpen(false);
        setIsCreationModalOpen(false);
      }}
      onSubmit={isEditModalOpen ? handleEditModalSubmit : handleCreationModalSubmit}
      initialValues={isEditModalOpen && editingAirEntry.entry ? {
        type: editingAirEntry.entry.type,
        width: editingAirEntry.entry.dimensions.width,
        height: editingAirEntry.entry.dimensions.height,
        distanceToFloor: editingAirEntry.entry.dimensions.distanceToFloor
      } : {
        type: currentAirEntry || 'window',
        width: 100,
        height: 60,
        distanceToFloor: 80
      }}
      isEditing={isEditModalOpen}
    />
  </>
);
Finally, modify your AirEntryModal component to support editing:
tsxCopyinterface AirEntryModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (values: AirEntry) => void;
  initialValues: {
    type: 'window' | 'door' | 'vent';
    width: number;
    height: number;
    distanceToFloor?: number;
  };
  isEditing: boolean; // Flag to indicate if we're editing or creating
}

const AirEntryModal: React.FC<AirEntryModalProps> = ({
  isOpen,
  onClose,
  onSubmit,
  initialValues,
  isEditing
}) => {
  const [formValues, setFormValues] = useState(initialValues);
  
  // Reset form when modal opens with new initialValues
  useEffect(() => {
    if (isOpen) {
      setFormValues(initialValues);
    }
  }, [isOpen, initialValues]);
  
  // ... form handling logic ...
  
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>
            {isEditing ? 'Edit' : 'Add'} {formValues.type.charAt(0).toUpperCase() + formValues.type.slice(1)}
          </DialogTitle>
        </DialogHeader>
        
        {/* Form fields */}
        <div className="space-y-4">
          {/* Type selection (for creation only) */}
          {!isEditing && (
            <div className="space-y-2">
              <Label>Type</Label>
              <Select 
                value={formValues.type} 
                onValueChange={(value) => setFormValues({...formValues, type: value as any})}
              >
                {/* Select options */}
              </Select>
            </div>
          )}
          
          {/* Width, height, distance to floor inputs */}
          <div className="space-y-2">
            <Label>Width (cm)</Label>
            <Input 
              type="number" 
              value={formValues.width} 
              onChange={(e) => setFormValues({...formValues, width: Number(e.target.value)})}
            />
          </div>
          
          {/* More form fields... */}
        </div>
        
        <DialogFooter>
          <Button variant="outline" onClick={onClose}>Cancel</Button>
          <Button onClick={() => onSubmit({
            ...formValues,
            // Other required fields will be filled by the parent component
          } as any)}>
            {isEditing ? 'Update' : 'Create'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};